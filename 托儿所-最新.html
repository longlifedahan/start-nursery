<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>开局托儿所</title>
    <style>
        * {
            touch-action: manipulation;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        /* 禁用下拉刷新/上滑刷新 */
        html,
        body {
            overscroll-behavior: none;
            overflow: hidden;
            /* 禁用滚动条 */
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* (1) 背景改成深绿 */
            background-color: #006400;
            /* 深绿色 */
            padding: 15px;
            min-height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* --- 头部区域 --- */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 600px;
            margin-bottom: 5px;
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        .score-time {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .score,
        .time {
            font-size: 14px;
            font-weight: bold;
            color: red;
        }

        .mode-indicator,
        .test-indicator {
            font-size: 11px;
            padding: 3px 6px;
            border-radius: 4px;
            background-color: #e0e0e0;
        }

        .mode-indicator.challenge {
            background-color: #ffe0b2;
            color: #e65100;
        }

        .header-buttons {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            padding: 4px 4px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 11px;
        }

        .header-btn:hover {
            background-color: #45a049;
        }

        /* --- 游戏网格区域 --- */
        .game-container {
            position: relative;
            /* (2) 黑框和方块间有一定间隙 */
            border: 5px solid black;
            padding: 5px;
            background-color: transparent;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);

            width: min(600px,
                    calc(100vw - 30px),
                    calc((100vh - 150px) / 1.6));

            aspect-ratio: 10 / 16;

            overflow: hidden;
            margin-bottom: 5px;
            flex-shrink: 0;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(16, 1fr);
            gap: 5px;
            background-color: transparent;
            width: 100%;
            height: 100%;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            /* 默认方块样式 */
            background-color: white;
            color: black;
            font-size: clamp(10px, 3.5vw, 16px);
            font-weight: bold;
            cursor: default;
            user-select: none;
            transition: background-color 0.1s;
            border-radius: 4px;
        }

        /* 消除后的空方块样式：无背景，无内容颜色 */
        .cell.empty-cell {
            background-color: transparent !important;
            /* 强制无背景 */
            color: transparent !important;
            /* 确保无数字残留 */
        }

        .cell.selected {
            color: red;
            background-color: #f8f8f8;
        }

        /* 消除特效 CSS */
        .cell.eliminated {
            animation: fadeOut 0.3s forwards;
            background-color: white;
        }

        @keyframes fadeOut {
            0% {
                transform: scale(1);
                opacity: 1;
                background-color: white;
            }

            /* 最终状态透明 */
            100% {
                transform: scale(0.1);
                opacity: 0;
                background-color: transparent;
            }
        }

        /* 其他 CSS 保持不变 */
        .selection-box {
            position: absolute;
            border: 2px dashed red;
            pointer-events: none;
            display: none;
        }

        /* --- 新增：帮助模式下的黄色虚线框样式 --- */
        .selection-box.help-selection {
            border: 3px dashed yellow;
            /* 醒目的黄色虚线 */
            /* 提升层级，确保在其他元素之上 */
            z-index: 999;
        }

        /* --- 底部控制按钮 CSS --- */
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 5px;
            width: 100%;
            max-width: 600px;
            justify-content: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .control-btn2 {
            flex-grow: 1;
            padding: 10px 5px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }

        .control-btn {
            flex-grow: 1;
            padding: 10px 5px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
            max-width: 120px;
        }

        .control-btn:hover {
            background-color: #1e87db;
        }

        .control-btn.challenge {
            background-color: #FF9800;
        }

        .control-btn.challenge:hover {
            background-color: #fb8c00;
        }

        .control-btn.end-game {
            background-color: #f44336;
        }

        .control-btn.end-game:hover {
            background-color: #d32f2f;
        }

        .control-btn.help {
            background-color: green;
        }

        /* --- 模态框和排行榜样式 --- */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .modal-content2 {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #555;
            transition: color 0.3s;
        }

        .close-btn:hover {
            color: #f44336;
        }

        .difficulty-slider {
            width: 250px;
        }

        /* 排行榜控制区域 */
        .sort-controls {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .sort-left,
        .sort-right {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* 模式/排序/切换按钮基础样式 */
        .mode-btn,
        .sort-btn,
        .toggle-btn {
            padding: 5px 8px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .mode-btn.active,
        .sort-btn.active,
        .toggle-btn:hover {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        /* 清空按钮 */
        .clear-btn {
            padding: 5px 8px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.3s;
        }

        .clear-btn:hover {
            background-color: #d32f2f;
        }

        /* 排行榜列表 */
        .leaderboard-list {
            list-style: none;
            padding: 0;
        }

        .leaderboard-item {
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 14px;
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-item .info {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            font-weight: bold;
        }

        .leaderboard-item .date-time {
            font-size: 12px;
            color: #666;
            min-width: 150px;
            text-align: right;
            flex-shrink: 0;
        }

        /* 游戏结束界面 */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }

        .restart-btn {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
        }
    </style>
</head>

<body>
    <div class="game-header">
        <div class="score-time">
            <div class="score"><span id="score">0</span>分</div>
            <div class="time">时<span id="time">00:00</span></div>
            <div class="mode-indicator" id="modeIndicator">普(10)</div>
            <div class="test-indicator" id="testIndicator">度(0)</div>
        </div>
        <div class="header-buttons">
            <button class="header-btn" id="settingsBtn">设置</button>
            <button class="header-btn" id="leaderboardBtn">排行</button>
            <button class="header-btn" id="undoBtn">撤回</button>
        </div>
    </div>

    <div class="game-container">
        <div class="grid" id="grid"></div>
        <div class="selection-box" id="selectionBox"></div>
        <div class="game-over" id="gameOver">
            <h2>游戏结束!</h2>
            <p>最终得分:<span id="finalScore">0</span></p>
            <p>用时:<span id="finalTime">00:00</span></p>
            <button class="restart-btn" id="restartBtn">重新开始</button>
            <button class="restart-btn" id="restartThisGameBtn">重开本局</button>
        </div>
    </div>

    <div class="controls">
        <button class="control-btn" id="newGameBtn">普通</button>
        <button class="control-btn challenge" id="challengeBtn">挑战</button>
        <button class="control-btn end-game" id="endGameBtn">结束</button>
        <button class="control-btn help" id="helpBtn">帮助</button>
        <button class="control-btn help" id="autoBtn">自动</button>
    </div>

    <div class="modal" id="leaderboardModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>排行榜</h2>
                <button class="close-btn" id="closeBtn">&times;</button>
            </div>
            <div class="sort-controls">
                <div class="sort-left">
                    <button class="mode-btn active" data-mode="all">全部记录</button>
                    <button class="mode-btn" data-mode="challenge">挑战榜</button>
                    <button class="mode-btn" data-mode="normal">普通榜</button>
                </div>
                <div class="sort-right">
                    <button class="toggle-btn" id="toggleShowAll" data-show="top10">显示全部记录</button>
                    <button class="clear-btn" id="clearLeaderboardBtn">清空记录</button>
                </div>
                <button class="sort-btn active" data-sort="score-desc" style="display: none;"></button>
            </div>
            <ul class="leaderboard-list" id="leaderboardList"></ul>
        </div>
    </div>

    <div class="modal" id="settingsModal">
        <div class="modal-content2">
            <!-- 难度设置，需重启 -->
            <div class="modal-header">
                <h2>游戏设置</h2>
                <button class="close-btn" id="closeSettingsBtn">&times;</button>
            </div>
            <p>当前难度等级: <span id="difficultyLevelDisplay">10</span></p>
            <input type="range" min="0" max="10" value="10" class="difficulty-slider" id="difficultySlider">
            <div>
                <button class="control-btn2" id="saveSettingsBtn"
                    style="width: 100%; margin-top: 15px;">确认难度设置</button>
            </div>
            <!-- 搜索阶数，单选 -->
            <p>搜索深度(无需重启)<input type="checkbox" id="allowTestGridCheckbox">使用自由度</input></p>
            <select id="searchDepthSelect" style="margin-top: 15px; width: 100%;">
                <option value="1" selected>搜索深度: 1 (快速)</option>
                <option value="2">搜索深度: 1 (慢速)</option>
                <option value="3">搜索深度: 2 (快速)</option>
                <option value="4">搜索深度: 2 (慢速)</option>
            </select>
            <!-- 新增保存/读取地图按钮 -->
            <p>保存/读取地图(不含操作)</p>
            <div style="margin: 15px 0; display: flex; gap: 10px;">
                <button class="control-btn" id="saveMapBtn" style="flex: 1;">保存地图</button>
                <button class="control-btn" id="loadMapBtn" style="flex: 1;">读取地图</button>
            </div>
            <p>初始解(无需重启,耗时↑):<span id="initLevelDisplay">55</span><input type="checkbox" id="allowSpeedUpCheckbox" checked>加速</input></p>
            <input type="range" min="0" max="100" value="55" class="difficulty-slider" id="initSlider">
            <!-- 重开本局 -->
            <div style="margin: 15px 0; display: flex; gap: 10px;">
                <button class="control-btn2" id="restartThisGameBtn2">重开本局</button>
            </div>
        </div>

        <script>
            // 【游戏状态和常量】
            const ROWS = 16;
            const COLS = 10;
            const TOP_RECORDS_COUNT = 10;
            const DIFFICULTY_PROBABILITIES_DATA = [
                { 1: 0.1500, 2: 0.1500, 3: 0.1000, 4: 0.1000, 5: 0.1000, 6: 0.1000, 7: 0.1000, 8: 0.1000, 9: 0.1000 },
                { 1: 0.1460, 2: 0.1460, 3: 0.1011, 4: 0.1011, 5: 0.1011, 6: 0.1011, 7: 0.1011, 8: 0.1011, 9: 0.1011 },
                { 1: 0.1420, 2: 0.1420, 3: 0.1023, 4: 0.1023, 5: 0.1023, 6: 0.1023, 7: 0.1023, 8: 0.1023, 9: 0.1023 },
                { 1: 0.1380, 2: 0.1380, 3: 0.1034, 4: 0.1034, 5: 0.1034, 6: 0.1034, 7: 0.1034, 8: 0.1034, 9: 0.1034 },
                { 1: 0.1340, 2: 0.1340, 3: 0.1046, 4: 0.1046, 5: 0.1046, 6: 0.1046, 7: 0.1046, 8: 0.1046, 9: 0.1046 },
                { 1: 0.1300, 2: 0.1300, 3: 0.1057, 4: 0.1057, 5: 0.1057, 6: 0.1057, 7: 0.1057, 8: 0.1057, 9: 0.1057 },
                { 1: 0.1260, 2: 0.1260, 3: 0.1069, 4: 0.1069, 5: 0.1069, 6: 0.1069, 7: 0.1069, 8: 0.1069, 9: 0.1069 },
                { 1: 0.1220, 2: 0.1220, 3: 0.1080, 4: 0.1080, 5: 0.1080, 6: 0.1080, 7: 0.1080, 8: 0.1080, 9: 0.1080 },
                { 1: 0.1180, 2: 0.1180, 3: 0.1092, 4: 0.1092, 5: 0.1092, 6: 0.1092, 7: 0.1092, 8: 0.1092, 9: 0.1092 },
                { 1: 0.1140, 2: 0.1140, 3: 0.1103, 4: 0.1103, 5: 0.1103, 6: 0.1103, 7: 0.1103, 8: 0.1103, 9: 0.1103 },
                { 1: 0.1111, 2: 0.1111, 3: 0.1111, 4: 0.1111, 5: 0.1111, 6: 0.1111, 7: 0.1111, 8: 0.1111, 9: 0.1111 }
            ]; // 难度矩阵（难度0-10）
            const SAVED_MAP_KEY = 'savedNumberEliminationMap'; // 保存地图的localStorage键
            const LOCAL_STORAGE_KEY = 'numberEliminationRecords';
            const SETTINGS_STORAGE_KEY = 'numberEliminationSettings';

            // 【游戏状态变量】
            // 1.游戏状态
            let gameState = {
                grid: [],
                originalGrid: [], // 原始地图
                score: 0,
                startTime: null,
                timer: null,
                isSelecting: false,
                startX: -1,
                startY: -1,
                endX: -1,
                endY: -1,
                selectedCells: [],
                gameOver: false,
                isChallengeMode: false,
                challengeTimeLimit: 180,
                challengeTimeRemaining: 0,
                allGameRecords: [],
                currentDifficulty: 10,
                history: [] // 操作历史，用于撤回
            };
            // 2.自动解决控制标志
            let isAutoSolving = false;
            let firstInit = true; // 标记是否为首次初始化
            // 3.获取DOM 元素
            const gridElement = document.getElementById('grid');
            const scoreElement = document.getElementById('score');
            const timeElement = document.getElementById('time');
            const gameOverElement = document.getElementById('gameOver');
            const leaderboardModal = document.getElementById('leaderboardModal');
            const leaderboardList = document.getElementById('leaderboardList');
            const modeBtns = document.querySelectorAll('.mode-btn');
            const toggleShowAllBtn = document.getElementById('toggleShowAll');
            const clearLeaderboardBtn = document.getElementById('clearLeaderboardBtn');
            const settingsModal = document.getElementById('settingsModal');
            const difficultySlider = document.getElementById('difficultySlider');
            const difficultyLevelDisplay = document.getElementById('difficultyLevelDisplay');
            const initSlider = document.getElementById('initSlider');
            const initLevelDisplay = document.getElementById('initLevelDisplay');
            const selectionBox = document.getElementById('selectionBox');

            // 【事件监听器 (添加 autoSolve 绑定) 】
            function setupEventListeners() {
                // 游戏控制
                document.getElementById('restartBtn').addEventListener('click', () => { initGame(gameState.isChallengeMode); });
                document.getElementById('newGameBtn').addEventListener('click', () => { initGame(false); });
                document.getElementById('challengeBtn').addEventListener('click', () => { initGame(true); });
                document.getElementById('endGameBtn').addEventListener('click', endGame);
                document.getElementById('helpBtn').addEventListener('click', helpme);
                document.getElementById('autoBtn').addEventListener('click', autoSolve); // <-- 绑定 autoSolve

                // 排行榜控制
                document.getElementById('leaderboardBtn').addEventListener('click', () => {
                    const activeMode = document.querySelector('.mode-btn.active').dataset.mode;
                    const showAll = document.getElementById('toggleShowAll').dataset.show === 'all';
                    showLeaderboard(activeMode, showAll);
                });
                document.getElementById('closeBtn').addEventListener('click', () => { leaderboardModal.style.display = 'none'; });

                // 设置控制
                document.getElementById('settingsBtn').addEventListener('click', openSettingsModal);
                document.getElementById('closeSettingsBtn').addEventListener('click', () => { settingsModal.style.display = 'none'; });
                document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);

                // 难度滑块变化时更新显示
                document.getElementById('difficultySlider').addEventListener('input', () => {
                    const level = parseInt(document.getElementById('difficultySlider').value);
                    document.getElementById('difficultyLevelDisplay').textContent = level;
                });

                // 初始解数滑块变化时更新显示
                document.getElementById('initSlider').addEventListener('input', () => {
                    const level = parseInt(document.getElementById('initSlider').value);
                    document.getElementById('initLevelDisplay').textContent = level;
                });

                // 排行榜模式切换
                modeBtns.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        const showAll = document.getElementById('toggleShowAll').dataset.show === 'all';
                        showLeaderboard(e.currentTarget.dataset.mode, showAll);
                    });
                });

                // 排行榜显示全部/部分切换
                document.getElementById('toggleShowAll').addEventListener('click', () => {
                    const currentState = document.getElementById('toggleShowAll').dataset.show;
                    const newState = currentState === 'top10' ? 'all' : 'top10';
                    const activeMode = document.querySelector('.mode-btn.active').dataset.mode;
                    showLeaderboard(activeMode, newState === 'all');
                });

                document.getElementById('clearLeaderboardBtn').addEventListener('click', clearLeaderboard);

                // 触摸和鼠标事件监听
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                // 撤回按钮事件
                document.getElementById('undoBtn').addEventListener('click', undoLastMove);
                // 保存地图按钮事件
                document.getElementById('saveMapBtn').addEventListener('click', saveCurrentMap);
                // 读取地图按钮事件
                document.getElementById('loadMapBtn').addEventListener('click', loadSavedMap);
                // 重开按钮事件
                document.getElementById('restartThisGameBtn').addEventListener('click', restartMap);
                document.getElementById('restartThisGameBtn2').addEventListener('click', restartMap);

            }

            // 【本地存储和设置逻辑】
            // 1.排行榜
            function loadRecords() {
                try {
                    const records = localStorage.getItem(LOCAL_STORAGE_KEY);
                    gameState.allGameRecords = records ? JSON.parse(records) : [];
                } catch (error) {
                    gameState.allGameRecords = [];
                }
            }
            function saveRecords() {
                try {
                    gameState.allGameRecords.sort((a, b) => b.score - a.score || a.time - b.time);
                    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(gameState.allGameRecords));
                } catch (error) { }
            }
            function clearLeaderboard() { // 清空排行榜
                if (confirm("确定要清除所有本地游戏记录吗？此操作不可撤销。")) {
                    gameState.allGameRecords = [];
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    document.getElementById('leaderboardModal').style.display = 'none';
                    alert("所有记录已清除。");
                    // 确保在清空后能正确显示空列表
                    const activeMode = document.querySelector('.mode-btn.active') ? document.querySelector('.mode-btn.active').dataset.mode : 'all';
                    showLeaderboard(activeMode, false);
                }
            }

            // 【游戏核心逻辑函数】
            // （辅助）生成随机数（根据概率）
            function generateRandomNumber(difficulty) {
                const probs = DIFFICULTY_PROBABILITIES_DATA[difficulty];
                const random = Math.random();
                let cumulativeProb = 0;
                let result = 1;

                for (let value = 1; value <= 9; value++) {
                    const prob = probs[value] || 0;
                    cumulativeProb += prob;

                    if (random < cumulativeProb) {
                        result = value;
                        break;
                    }
                }
                return result;
            }
            // 1.生成初始地图
            function generateGrid() {
                let initVal = document.getElementById('initSlider').value;
                let totalSum = 0; // 用于统计前面所有数字的和
                let count = 0;
                let bestcount = 0;
                do {
                    const currentDifficulty = gameState.currentDifficulty;
                    gameState.grid = [];
                    for (let i = 0; i < ROWS; i++) {
                        const row = [];
                        for (let j = 0; j < COLS; j++) {
                            // 判断是否是最后一行最后一列的单元格
                            const isLastCell = i === ROWS - 1 && j === COLS - 1;
                            let value;
                            if (!isLastCell) {
                                // 非最后一个单元格，正常生成并累加总和
                                value = generateRandomNumber(currentDifficulty);
                                totalSum += value;
                            } else {
                                // 最后一个单元格：计算互补值
                                const remainder = totalSum % 10;
                                // 计算需要的互补值（使总和能被10整除）
                                const complement = remainder === 0 ? 0 : 10 - remainder;

                                // 根据规则处理：1-9用互补值，0则随机生成
                                if (complement >= 1 && complement <= 9) {
                                    value = complement;
                                } else {
                                    value = generateRandomNumber(currentDifficulty);
                                }

                                // 累加最后一个值到总和（可选，用于日志）
                                totalSum += value;
                            }
                            row.push({ value: value });
                        }
                        gameState.grid.push(row);
                    }
                    // 始终记录当前最佳（最多初始解）地图
                    let possibleMoves = testGrid();
                    if (possibleMoves > bestcount) {
                        bestcount = possibleMoves;
                        gameState.bestgrid = JSON.parse(JSON.stringify(gameState.grid));
                    } else {
                        gameState.grid = JSON.parse(JSON.stringify(gameState.bestgrid));
                    }
                    // 确保初始地图有足够的可消除空间
                    count = count + 1;
                    // console.log("初始可消除空间:", testGrid(), "尝试次数:", count);
                    // 适当降低初始解数要求，防止死循环
                    if (count % 10000 === 0) {
                        if (document.getElementById('allowSpeedUpCheckbox').checked || (initVal + parseInt(document.getElementById('difficultySlider').value) > 97)) {
                            if (initVal > 95 - parseInt(document.getElementById('difficultySlider').value)) {
                                initVal--;
                                console.log("降低初始解数要求为:", initVal);
                            }
                        }
                    }
                } while (testGrid() < initVal);
                console.log("初始可消除空间:", testGrid(), "尝试次数:", count);
            }

            function testGrid() {
                return findAllPossibleMoves(gameState.grid).length;
            }

            // 2.初始化游戏
            function initGame(isChallenge = false) {
                gameState.score = 0;
                gameState.gameOver = false;
                gameState.isChallengeMode = isChallenge;
                gameState.startTime = new Date();

                // 停止任何正在进行的自动解决进程
                if (isAutoSolving) autoSolve();

                const modeName = isChallenge ? "挑" : "普";
                document.getElementById('modeIndicator').textContent = `${modeName}(${gameState.currentDifficulty})`;
                document.getElementById('modeIndicator').classList.toggle('challenge', isChallenge);

                scoreElement.textContent = '0';

                if (gameState.timer) clearInterval(gameState.timer);
                if (isChallenge) {
                    gameState.challengeTimeRemaining = gameState.challengeTimeLimit;
                    gameState.timer = setInterval(updateChallengeTime, 1000);
                } else {
                    gameState.timer = setInterval(updateTime, 1000);
                }

                document.getElementById('finalScore').textContent = '0';
                document.getElementById('finalTime').textContent = '00:00';
                gameOverElement.style.display = 'none';
                selectionBox.style.display = 'none';

                generateGrid();

                // 保存原始地图的深拷贝
                gameState.originalGrid = JSON.parse(JSON.stringify(gameState.grid));
                renderGrid();

                document.getElementById('testIndicator').textContent = `度(${testGrid()})`;

                if (firstInit) {
                    alert("游戏规则：框选数字，达到10消除，普通模式无时间限制，挑战模式3分钟内尽可能多得分。设置中可调整难度和初始解数。祝你好运！");
                    firstInit = false;
                } else {
                    if (testGrid() >= 80) {
                        alert("地图生成完毕，初始可消除空间:" + testGrid());
                    }
                }
            }
            // 3.渲染游戏地图
            function renderGrid() {
                gridElement.innerHTML = '';
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        const cell = gameState.grid[i][j];
                        const cellElement = document.createElement('div');
                        cellElement.className = 'cell';

                        if (cell.value === 0) {
                            cellElement.classList.add('empty-cell');
                        }

                        cellElement.textContent = cell.value !== 0 ? cell.value : '';
                        cellElement.dataset.row = i;
                        cellElement.dataset.col = j;
                        cellElement.addEventListener('touchstart', handleTouchStart);
                        cellElement.addEventListener('mousedown', handleMouseDown);
                        gridElement.appendChild(cellElement);
                    }
                }
            }
            // 4.鼠标移动和选择（对应画框和选择）
            function handleTouchStart(e) {
                e.stopPropagation();
                if (gameState.gameOver || isAutoSolving) return;
                const cell = e.currentTarget;
                startSelection(parseInt(cell.dataset.row), parseInt(cell.dataset.col));
            }
            function handleMouseDown(e) {
                if (e.button !== 0 || gameState.gameOver || isAutoSolving) return;
                const cell = e.currentTarget;
                startSelection(parseInt(cell.dataset.row), parseInt(cell.dataset.col));
            }
            function handleTouchMove(e) {
                if (!gameState.isSelecting) return;
                e.preventDefault();
                const touch = e.touches[0];
                const cell = getCellFromCoordinates(touch.clientX, touch.clientY);
                if (cell) {
                    updateSelectionFromCell(cell);
                }
            }
            function handleMouseMove(e) {
                if (!gameState.isSelecting) return;
                const cell = e.target.closest('.cell');
                if (cell) {
                    updateSelectionFromCell(cell);
                }
            }
            function handleTouchEnd(e) {
                e.stopPropagation();
                if (gameState.isSelecting) {
                    endSelection();
                }
            }
            function handleMouseUp(e) {
                if (e.button === 0 && gameState.isSelecting) {
                    endSelection();
                }
            }
            // 5.选择框和选中格子更新
            function getCellFromCoordinates(x, y) {
                const gridRect = gridElement.getBoundingClientRect();
                if (x < gridRect.left || x > gridRect.right || y < gridRect.top || y > gridRect.bottom) {
                    return null;
                }
                const cellWidth = gridRect.width / COLS;
                const cellHeight = gridRect.height / ROWS;
                const col = Math.floor((x - gridRect.left) / cellWidth);
                const row = Math.floor((y - gridRect.top) / cellHeight);
                if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                    return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                }
                return null;
            }
            // 6.开始选择
            function startSelection(row, col) {
                gameState.isSelecting = true;
                gameState.startX = row;
                gameState.startY = col;
                gameState.endX = row;
                gameState.endY = col;
                gameState.selectedCells = [[row, col]];
                clearHighlightSuggestion();
                updateSelectionBox();
                selectionBox.style.display = 'block';
                updateSelectedCells();
            }
            // 7.更新选择
            function updateSelectionFromCell(cell) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                gameState.endX = row;
                gameState.endY = col;

                const minRow = Math.min(gameState.startX, gameState.endX);
                const maxRow = Math.max(gameState.startX, gameState.endX);
                const minCol = Math.min(gameState.startY, gameState.endY);
                const maxCol = Math.max(gameState.startY, gameState.endY);

                gameState.selectedCells = [];
                for (let i = minRow; i <= maxRow; i++) {
                    for (let j = minCol; j <= maxCol; j++) {
                        if (gameState.grid[i][j].value !== 0) {
                            gameState.selectedCells.push([i, j]);
                        }
                    }
                }
                updateSelectionBox();
                updateSelectedCells();
            }
            // 8.更新选择框位置和大小
            function updateSelectionBox() {
                const startCell = document.querySelector(`.cell[data-row="${gameState.startX}"][data-col="${gameState.startY}"]`);
                const endCell = document.querySelector(`.cell[data-row="${gameState.endX}"][data-col="${gameState.endY}"]`);

                if (!startCell || !endCell) return;

                const startRect = startCell.getBoundingClientRect();
                const endRect = endCell.getBoundingClientRect();
                const gridRect = gridElement.getBoundingClientRect();

                const left = Math.min(startRect.left, endRect.left) - gridRect.left;
                const top = Math.min(startRect.top, endRect.top) - gridRect.top;
                const width = Math.abs(startRect.left - endRect.left) + startCell.offsetWidth;
                const height = Math.abs(startRect.top - endRect.top) + startCell.offsetHeight;

                selectionBox.style.left = `${left}px`;
                selectionBox.style.top = `${top}px`;
                selectionBox.style.width = `${width}px`;
                selectionBox.style.height = `${height}px`;
            }
            // 9.更新选中格子样式
            function updateSelectedCells() {
                document.querySelectorAll('.cell.selected').forEach(cell => {
                    cell.classList.remove('selected');
                });
                gameState.selectedCells.forEach(([row, col]) => {
                    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('selected');
                });
            }
            // 10.结束选择并处理结果
            function endSelection() {
                selectionBox.style.display = 'none';

                let sum = 0;
                gameState.selectedCells.forEach(([row, col]) => {
                    sum += gameState.grid[row][col].value;
                });

                if (sum === 10) {
                    eliminateCells();
                } else {
                    document.querySelectorAll('.cell.selected').forEach(cell => {
                        cell.classList.remove('selected');
                    });
                }

                gameState.isSelecting = false;
                gameState.selectedCells = [];
            }
            // 11.消除选中格子
            function eliminateCells() {
                // 保存历史记录
                const historyItem = {
                    grid: JSON.parse(JSON.stringify(gameState.grid)),
                    score: gameState.score,
                    time: gameState.isChallengeMode ?
                        gameState.challengeTimeRemaining :
                        Math.floor((new Date() - gameState.startTime) / 1000)
                };
                gameState.history.push(historyItem);
                // 更新格子
                gameState.selectedCells.forEach(([row, col]) => {
                    gameState.grid[row][col].value = 0;
                    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                    if (cell) {
                        cell.classList.add('eliminated');
                        cell.classList.remove('selected');
                        setTimeout(() => {
                            cell.classList.remove('eliminated');
                            cell.textContent = '';
                            cell.classList.add('empty-cell');
                        }, 300);
                    }
                });
                gameState.score += gameState.selectedCells.length;
                scoreElement.textContent = gameState.score;
                document.getElementById('testIndicator').textContent = `度(${testGrid()})`;
                checkGameOver();
            }
            // 12.检查游戏是否结束        
            function checkGameOver() {
                if (gameState.isChallengeMode) return;

                // 使用 findAllPossibleMoves 来检查是否还有剩余移动
                const moves = findAllPossibleMoves(gameState.grid);
                if (moves.length === 0) {
                    helpme(); // 触发一次帮助，显示最后的可能
                    alert("找不到可以继续消除的组合，游戏结束");
                    endGame();
                }
            }
            // 13.结束游戏
            function endGame() {
                if (gameState.gameOver) return;

                gameState.gameOver = true;
                clearInterval(gameState.timer);

                const endTime = new Date();
                const timeTaken = gameState.isChallengeMode
                    ? gameState.challengeTimeLimit - gameState.challengeTimeRemaining
                    : Math.floor((endTime - gameState.startTime) / 1000);

                const minutes = Math.floor(timeTaken / 60).toString().padStart(2, '0');
                const seconds = (timeTaken % 60).toString().padStart(2, '0');

                document.getElementById('finalScore').textContent = gameState.score;
                document.getElementById('finalTime').textContent = `${minutes}:${seconds}`;
                gameOverElement.style.display = 'block';

                const now = new Date();
                const newRecord = {
                    score: gameState.score,
                    time: timeTaken,
                    isChallenge: gameState.isChallengeMode,
                    date: now.toISOString(),
                    difficulty: gameState.currentDifficulty
                };
                gameState.allGameRecords.push(newRecord);
                saveRecords();

                // 游戏结束时停止自动解决
                if (isAutoSolving) autoSolve();
            }

            // 【辅助功能】
            // 1.帮助按钮
            function helpme() {
                if (gameState.gameOver || gameState.isSelecting) return;

                clearHighlightSuggestion();

                // 查找第一个可消除的移动并高亮
                const moves = findAllPossibleMoves(gameState.grid);
                if (moves.length > 0) {
                    const move = moves[Math.floor(Math.random() * moves.length)];
                    highlightSuggestion(move.r1, move.c1, move.r2, move.c2);
                    return;
                }
                alert("找不到可以消除的组合")
            }
            // 2.高亮显示建议
            function highlightSuggestion(startRow, startCol, endRow, endCol) {
                const startCell = document.querySelector(`.cell[data-row="${startRow}"][data-col="${startCol}"]`);
                const endCell = document.querySelector(`.cell[data-row="${endRow}"][data-col="${endCol}"]`);

                if (!startCell || !endCell) return;

                const startRect = startCell.getBoundingClientRect();
                const endRect = endCell.getBoundingClientRect();
                const gridRect = gridElement.getBoundingClientRect();

                const left = Math.min(startRect.left, endRect.left) - gridRect.left;
                const top = Math.min(startRect.top, endRect.top) - gridRect.top;
                const width = Math.abs(startRect.left - endRect.left) + startCell.offsetWidth + 8;
                const height = Math.abs(startRect.top - endRect.top) + startCell.offsetHeight + 8;

                selectionBox.style.left = `${left}px`;
                selectionBox.style.top = `${top}px`;
                selectionBox.style.width = `${width}px`;
                selectionBox.style.height = `${height}px`;

                selectionBox.classList.add('help-selection');
                selectionBox.style.display = 'block';

                setTimeout(clearHighlightSuggestion, 5000);
            }
            // 3.清除高亮建议
            function clearHighlightSuggestion() {
                selectionBox.classList.remove('help-selection');
                selectionBox.style.display = 'none';
            }
            // 4.更新计时器
            function updateTime() {
                if (!gameState.startTime || gameState.gameOver) return;
                const currentTime = new Date();
                const timeTaken = Math.floor((currentTime - gameState.startTime) / 1000);
                const minutes = Math.floor(timeTaken / 60).toString().padStart(2, '0');
                const seconds = (timeTaken % 60).toString().padStart(2, '0');
                document.getElementById('time').textContent = `${minutes}:${seconds}`;
            }
            // 5.更新挑战模式计时器
            function updateChallengeTime() {
                if (gameState.gameOver) return;
                gameState.challengeTimeRemaining--;
                const minutes = Math.floor(gameState.challengeTimeRemaining / 60).toString().padStart(2, '0');
                const seconds = (gameState.challengeTimeRemaining % 60).toString().padStart(2, '0');
                document.getElementById('time').textContent = `${minutes}:${seconds}`;
                if (gameState.challengeTimeRemaining <= 0) {
                    endGame();
                }
            }
            // (辅助) 格式化记录日期
            function formatRecordDate(isoString) {
                const date = new Date(isoString);
                const Y = date.getFullYear();
                const M = (date.getMonth() + 1).toString().padStart(2, '0');
                const D = date.getDate().toString().padStart(2, '0');
                const h = date.getHours().toString().padStart(2, '0');
                const m = date.getMinutes().toString().padStart(2, '0');
                const s = date.getSeconds().toString().padStart(2, '0');
                return `${Y}-${M}-${D} ${h}:${m}:${s}`;
            }
            // 6.显示排行榜
            function showLeaderboard(mode, showAll) {
                let records = [...gameState.allGameRecords];
                records.sort((a, b) => b.score - a.score || a.time - b.time);

                if (mode === 'challenge') {
                    records = records.filter(record => record.isChallenge);
                } else if (mode === 'normal') {
                    records = records.filter(record => !record.isChallenge);
                }

                const recordsToShow = showAll ? records : records.slice(0, TOP_RECORDS_COUNT);

                document.getElementById('toggleShowAll').textContent = showAll ? `仅显示前 ${TOP_RECORDS_COUNT} 条` : '显示全部记录';
                document.getElementById('toggleShowAll').dataset.show = showAll ? 'all' : 'top10';

                leaderboardList.innerHTML = '';

                if (recordsToShow.length === 0) {
                    const item = document.createElement('li');
                    item.className = 'leaderboard-item';
                    item.innerHTML = '暂无记录';
                    leaderboardList.appendChild(item);
                } else {
                    recordsToShow.forEach((record, index) => {
                        const time = record.time;
                        const minutes = Math.floor(time / 60).toString().padStart(2, '0');
                        const seconds = (time % 60).toString().padStart(2, '0');
                        const modeLabel = record.isChallenge ? '<span style="color:#e65100;">[挑战]</span>' : '<span style="color:#2196F3;">[普通]</span>';
                        const formattedDate = record.date ? formatRecordDate(record.date) : '';
                        const difficultyDisplay = record.difficulty !== undefined ? ` (难度: ${record.difficulty})` : '';

                        const item = document.createElement('li');
                        item.className = 'leaderboard-item'; // 使用 CSS 类
                        item.innerHTML = `
                        <div class="info">
                            <span>${index + 1}. ${modeLabel} 分数: ${record.score}${difficultyDisplay}</span>
                            <span>用时: ${minutes}:${seconds}</span>
                        </div>
                        <span class="date-time">${formattedDate}</span>
                    `;
                        leaderboardList.appendChild(item);
                    });
                }
                leaderboardModal.style.display = 'flex';
            }
            // 7.打开设置模态框
            function openSettingsModal() {
                difficultySlider.value = gameState.currentDifficulty;
                difficultyLevelDisplay.textContent = gameState.currentDifficulty;
                settingsModal.style.display = 'flex';
            }
            // 8.
            function saveSettings() {
                const newDifficulty = parseInt(difficultySlider.value);

                if (newDifficulty !== gameState.currentDifficulty) {
                    gameState.currentDifficulty = newDifficulty;
                }

                settingsModal.style.display = 'none';
            }

            // 【自动解决功能】
            // 1.自动解决主函数
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            // 2.使用二维前缀和 (SAT) 查找所有矩形移动。
            function findAllPossibleMoves(currentGrid) {
                const R = ROWS;
                const C = COLS;
                // 构建二维前缀和表 (Summed Area Table)
                const prefixSum = Array(R + 1).fill(0).map(() => Array(C + 1).fill(0));
                const prefixCount = Array(R + 1).fill(0).map(() => Array(C + 1).fill(0));

                // O(R*C) 预计算
                for (let r = 0; r < R; r++) {
                    for (let c = 0; c < C; c++) {
                        const value = currentGrid[r][c].value;
                        const count = value !== 0 ? 1 : 0;

                        // 计算公式: D - B - C + A
                        prefixSum[r + 1][c + 1] = value + prefixSum[r][c + 1] + prefixSum[r + 1][c] - prefixSum[r][c];
                        prefixCount[r + 1][c + 1] = count + prefixCount[r][c + 1] + prefixCount[r + 1][c] - prefixCount[r][c];
                    }
                }

                // O(1) 查询矩形值
                const getRectValue = (table, r1, c1, r2, c2) => {
                    const D = table[r2 + 1][c2 + 1];
                    const B = table[r1][c2 + 1];
                    const C_val = table[r2 + 1][c1];
                    const A = table[r1][c1];
                    return D - B - C_val + A;
                };

                const moves = [];
                // O((R*C)^2) 搜索
                for (let r1 = 0; r1 < R; r1++) {
                    for (let c1 = 0; c1 < C; c1++) {

                        for (let r2 = r1; r2 < R; r2++) {
                            for (let c2 = c1; c2 < C; c2++) {

                                const sum = getRectValue(prefixSum, r1, c1, r2, c2);

                                // 早期退出：如果和超过 10，则以 (r1, c1) 开始，以 (r2, c2) 结束的所有更大矩形都不可能为 10
                                if (sum > 10) continue;

                                if (sum === 10) {
                                    const cellsCount = getRectValue(prefixCount, r1, c1, r2, c2);
                                    // 检查四个边界是否包含非零元素（完整范围检查，不排除任何行）
                                    // 1. 第一行（r1）从c1到c2的完整范围
                                    const hasFirstRowNonZero = getRectValue(prefixCount, r1, c1, r1, c2) > 0;
                                    // 2. 最后一行（r2）从c1到c2的完整范围
                                    const hasLastRowNonZero = getRectValue(prefixCount, r2, c1, r2, c2) > 0;
                                    // 3. 第一列（c1）从r1到r2的完整范围（包括r1和r2）
                                    const hasFirstColNonZero = getRectValue(prefixCount, r1, c1, r2, c1) > 0;
                                    // 4. 最后一列（c2）从r1到r2的完整范围（包括r1和r2）
                                    const hasLastColNonZero = getRectValue(prefixCount, r1, c2, r2, c2) > 0;

                                    // 四个边界都有非零元素才视为有效
                                    if (hasFirstRowNonZero && hasLastRowNonZero && hasFirstColNonZero && hasLastColNonZero) {
                                        moves.push({ r1, c1, r2, c2, cellsCount });
                                    }
                                }
                            }
                        }
                    }
                }
                return moves;
            }

            // 3.A* 启发式函数 h(n)
            function calculateHeuristic(currentGrid) {
                let totalCells = 0;
                let smallCells = 0; // 1, 2, 3 的数量
                let bigCells = 0;   // 7, 8, 9 的数量

                // 遍历计算剩余方块总数 (N_total) 和小数字数量 (N_1,2,3)
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        const value = currentGrid[i][j].value;
                        if (value !== 0) {
                            totalCells++;
                            if (value <= 3) {
                                smallCells++;
                            }
                            if (value >= 7) {
                                bigCells++;
                            }
                        }
                    }
                }
                // 最大潜在消除得分 (S_pot)
                const potentialScore = Math.floor(totalCells / 2);
                // 小数字保留奖励 (B_small): 作为浮点数奖励，影响平局决策
                const retentionBonus = smallCells / 5.0;
                // 大数字惩罚 (P_big): 作为浮点数惩罚，影响平局决策
                const bigPenalty = bigCells / 15.0;
                // 自由度
                let remainingDepth = document.getElementById('searchDepthSelect').value;
                let possibleMoves = 0;
                // 仅一阶搜索加入自由度辅助
                if ((remainingDepth === '1' || remainingDepth === '2') && document.getElementById('allowTestGridCheckbox').checked) {
                    possibleMoves = testGrid();
                    // 自由度<5时，需要尽量增加自由度
                    if(possibleMoves < 5) {
                        possibleMoves = possibleMoves * 2.0;
                    }
                    // 自由度5-15时，保持自由度权重
                    else if(possibleMoves < 15) {
                        possibleMoves = possibleMoves;
                    }
                    // 自由度15-35时，略微降低自由度权重
                    else if(possibleMoves < 35) {
                        possibleMoves = possibleMoves / 5.0;
                    }
                    // 自由度>35时，大幅降低自由度权重
                    else {
                        possibleMoves = possibleMoves / 10.0;
                    }
                }
                // 启发式分数 = 潜在得分 + 浮点奖励 - 浮点惩罚
                return potentialScore + retentionBonus - bigPenalty + possibleMoves;
            }

            // 4.递归深度搜索，用于计算从当前状态开始的 N 步内能获得的最高分数估值。
            function findMaxScoreInNSteps(currentGrid, depth) {
                if (depth === 0) {
                    // 到达搜索深度限制，返回 A* 启发式估值 h(n)
                    return calculateHeuristic(currentGrid);
                }

                const moves = findAllPossibleMoves(currentGrid);
                if (moves.length === 0) {
                    return 0; // 无法移动，后续分数为 0
                }

                let maxFutureScore = 0;

                // 优先搜索高分路径 (贪婪启发式)
                moves.sort((a, b) => b.cellsCount - a.cellsCount);

                for (const move of moves) {
                    const scoreThisStep = move.cellsCount;
                    // 1. 执行移动，创建新网格
                    const nextGrid = currentGrid.map(row => row.map(cell => ({ ...cell })));
                    for (let r = move.r1; r <= move.r2; r++) {
                        for (let c = move.c1; c <= move.c2; c++) {
                            nextGrid[r][c].value = 0;
                        }
                    }
                    // 2. 递归搜索下一层，计算后续分数估值
                    const scoreFromNextSteps = findMaxScoreInNSteps(nextGrid, depth - 1);
                    const totalPotentialScore = scoreThisStep + scoreFromNextSteps;
                    if (totalPotentialScore > maxFutureScore) {
                        maxFutureScore = totalPotentialScore;
                    }
                }
                return maxFutureScore;
            }

            // 5.寻找当前状态下的最佳移动（3 步深度，A* 启发式）——深度为 3 的向前搜索：选择使 f(n) = g(n) + h(n) 最高的移动。
            // g(n): 当前步分数，h(n): 剩余 2 步的最优分数估值 (通过 findMaxScoreInNSteps 计算)
            function findBest2StepMove(currentGrid) {
                const moves = findAllPossibleMoves(currentGrid);
                if (moves.length === 0) {
                    return null;
                }

                let bestMove = null;
                let maxEvaluationScore = -1;

                // 遍历所有第一步可能的移动
                for (const move1 of moves) {
                    const g_n = move1.cellsCount; // g(n): 实际已获分数 (第一步)

                    // 1. 执行第一步移动，创建新网格
                    const nextGrid1 = currentGrid.map(row => row.map(cell => ({ ...cell })));
                    for (let r = move1.r1; r <= move1.r2; r++) {
                        for (let c = move1.c1; c <= move1.c2; c++) {
                            nextGrid1[r][c].value = 0;
                        }
                    }

                    let remainingDepth = document.getElementById('searchDepthSelect').value;

                    // 2. 递归计算剩余 X 步的最佳分数估值 (h(n))
                    if ((remainingDepth === '1' || remainingDepth === '2')) {
                        h_n = findMaxScoreInNSteps(nextGrid1, 1); // 2 步深度
                    } else {
                        h_n = findMaxScoreInNSteps(nextGrid1, 2); // 3 步深度
                    }

                    // A* 评估函数：f(n) = g(n) + h(n)
                    const evaluationScore = g_n + 1.5 * h_n;

                    // 3. 更新最佳移动
                    if (evaluationScore > maxEvaluationScore) {
                        maxEvaluationScore = evaluationScore;
                        bestMove = {
                            move: move1,
                            // 存储执行第一步后的网格状态，方便下一步的UI/逻辑同步
                            nextGrid: nextGrid1
                        };
                    }
                }

                return bestMove;
            }

            // 6.自动解决游戏的异步主函数
            async function autoSolve() {
                // 停止功能
                if (isAutoSolving) {
                    isAutoSolving = false;
                    document.getElementById('autoBtn').textContent = '自动';
                    console.log("自动解决已停止。");
                    return;
                }
                if (gameState.gameOver || gameState.isSelecting) {
                    console.log("游戏已结束或正在选择中，无法自动解决。");
                    return;
                }
                isAutoSolving = true;
                document.getElementById('autoBtn').textContent = '停止';
                console.log("自动解决开始...");

                clearHighlightSuggestion();

                let stepCount = 0;

                while (isAutoSolving) {
                    // --- 状态同步（要求 2） ---
                    // 每次循环开始时，都读取当前最新的游戏状态，以应对用户手动操作
                    const currentGrid = gameState.grid;

                    // 1. 寻找当前状态下的最佳（3步深度，A*启发式）移动
                    const startTime = performance.now();
                    const bestStep = findBest2StepMove(currentGrid);
                    const endTime = performance.now();

                    if (!bestStep) {
                        console.log("找不到可以继续消除的组合，自动解决停止。");
                        break;
                    }

                    const { move } = bestStep;
                    const { r1, c1, r2, c2 } = move;

                    // 2. 模拟操作和执行
                    // A. 模拟 SelectionBox 效果
                    highlightSuggestion(r1, c1, r2, c2);
                    // B. 模拟 SelectedCells 效果 (用于消除)
                    const minRow = Math.min(r1, r2);
                    const maxRow = Math.max(r1, r2);
                    const minCol = Math.min(c1, c2);
                    const maxCol = Math.max(c1, c2);
                    gameState.selectedCells = [];
                    for (let i = minRow; i <= maxRow; i++) {
                        for (let j = minCol; j <= maxCol; j++) {
                            if (gameState.grid[i][j].value !== 0) {
                                const cellEl = document.querySelector(`.cell[data-row="${i}"][data-col="${j}"]`);
                                if (cellEl) cellEl.classList.add('selected');
                                gameState.selectedCells.push([i, j]);
                            }
                        }
                    }
                    // C. 停顿 0.2 秒
                    if (!isAutoSolving) break;
                    let remainingDepth = document.getElementById('searchDepthSelect').value;
                    if (remainingDepth === '1' || remainingDepth === '3') {
                        await sleep(20);
                    }
                    else {
                        await sleep(200);
                    }
                    if (!isAutoSolving) break;
                    // D. 执行消除逻辑 (会更新 gameState.grid 和 gameState.score)
                    eliminateCells();
                    // E. 清除高亮
                    clearHighlightSuggestion();
                    if (!isAutoSolving) break;
                    // F. 等待消除特效完成
                    if (remainingDepth === '1' || remainingDepth === '3') {
                        await sleep(30);
                    }
                    else {
                        await sleep(300);
                    }
                    if (!isAutoSolving) break;
                    // G. 重新渲染网格
                    renderGrid();
                    stepCount++;
                }

                // 自动解决结束后重置标志
                isAutoSolving = false;
                document.getElementById('autoBtn').textContent = '自动';
                console.log(`自动解决完成，共执行 ${stepCount} 步。`);
                if (gameState.isChallengeMode) {
                    helpme();
                }
            }

            // 【撤回相关】
            // 1.添加保存地图到localStorage的函数
            function saveCurrentMap() {
                try {
                    const mapData = {
                        grid: gameState.originalGrid,
                        difficulty: gameState.currentDifficulty,
                        savedTime: new Date().toISOString()
                    };
                    localStorage.setItem(SAVED_MAP_KEY, JSON.stringify(mapData));
                    alert("地图保存成功");
                } catch (error) {
                    alert("地图保存失败: " + error.message);
                }
            }

            // （辅助）重开辅助准备
            function prepareForRestart() {
                // 初始化
                gameState.score = 0;
                gameState.gameOver = false;
                isChallenge = gameState.isChallengeMode;
                gameState.startTime = new Date();

                // 停止任何正在进行的自动解决进程
                if (isAutoSolving) autoSolve();

                const modeName = isChallenge ? "挑" : "普";
                document.getElementById('modeIndicator').textContent = `${modeName}(${gameState.currentDifficulty})`;
                document.getElementById('modeIndicator').classList.toggle('challenge', isChallenge);

                scoreElement.textContent = '0';

                if (gameState.timer) clearInterval(gameState.timer);
                if (isChallenge) {
                    gameState.challengeTimeRemaining = gameState.challengeTimeLimit;
                    gameState.timer = setInterval(updateChallengeTime, 1000);
                } else {
                    gameState.timer = setInterval(updateTime, 1000);
                }

                document.getElementById('finalScore').textContent = '0';
                document.getElementById('finalTime').textContent = '00:00';
                gameOverElement.style.display = 'none';
                selectionBox.style.display = 'none';
            }

            // 2.添加读取保存的地图的函数
            function loadSavedMap() {
                try {
                    prepareForRestart();
                    // 读取并更新
                    const savedData = localStorage.getItem(SAVED_MAP_KEY);
                    if (!savedData) {
                        alert("没有保存的地图");
                        return false;
                    }
                    const mapData = JSON.parse(savedData);
                    gameState.grid = JSON.parse(JSON.stringify(mapData.grid));
                    gameState.originalGrid = JSON.parse(JSON.stringify(mapData.grid));
                    gameState.currentDifficulty = mapData.difficulty;
                    gameState.score = 0;
                    gameState.history = []; // 清空历史记录
                    scoreElement.textContent = '0';

                    // 更新难度显示
                    difficultySlider.value = gameState.currentDifficulty;
                    difficultyLevelDisplay.textContent = gameState.currentDifficulty;

                    // 关闭重新开始游戏框
                    gameOverElement.style.display = 'none';
                    gameState.gameOver = false;

                    renderGrid();
                    alert("地图加载成功");
                    return true;
                } catch (error) {
                    alert("地图加载失败: " + error.message);
                    return false;
                }
            }

            // 3.重开功能
            function restartMap() {
                prepareForRestart();
                const mapData = gameState.originalGrid;
                gameState.grid = JSON.parse(JSON.stringify(mapData));
                gameState.score = 0;
                gameState.history = []; // 清空历史记录
                scoreElement.textContent = '0';
                renderGrid();
            }

            // 4.撤回功能
            function undoLastMove() {
                if (gameState.history.length === 0) {
                    alert("没有可撤回的操作");
                    return;
                }

                // 取出最后一步记录
                const lastState = gameState.history.pop();

                // 恢复状态
                gameState.grid = lastState.grid;
                gameState.score = lastState.score;
                scoreElement.textContent = gameState.score;

                // 恢复时间
                if (gameState.isChallengeMode) {
                    gameState.challengeTimeRemaining = lastState.time;
                    updateChallengeTime();
                } else {
                    // 调整开始时间以保持正确的显示时间
                    const currentTime = new Date();
                    const elapsedTime = Math.floor((currentTime - gameState.startTime) / 1000);
                    const newElapsedTime = (new Date() - gameState.startTime) / 1000 - (elapsedTime - lastState.time);
                    gameState.startTime = new Date(currentTime - newElapsedTime * 1000);
                    updateTime();
                }

                renderGrid();
            }

            // 初始化
            function init() {
                loadRecords();
                setupEventListeners();
                initGame();
            }

            // 启动游戏
            init();
        </script>
</body>

</html>
